
#include<thread>
#include<vector>
#include<fstream>
#include<sstream>
#include <algorithm>

//ポトレアニメの定義ファイルパス
#define CSVPATH "dll/potanim.csv"

//SFFファイル名
#define SFFNAME "CC.sff"

//戻ってきたやつのパラメーターを弄らないとポトレに使えない
int TuneForPot(int ad){
	*(*(*((int***)ad)+0x18/4)+0x18/4)=9000;
	*(*(*((int***)ad)+0x18/4)+0x1c/4)=1;
	*(*(*((int***)ad+0x8/4)+0x18/4)+0x18/4)=9000;
	*(*(*((int***)ad+0x8/4)+0x18/4)+0x1c/4)=0;
	return ad;
}

//csvを読む
void ReadDataFile(std::vector<std::vector<int>>& data,const char* datapath){
	std::ifstream in(datapath);
	std::string tmpstr,tmpstr2;
	int grpno, imgno, time;
	while(std::getline(in,tmpstr)){
		tmpstr2 = "";
		std::replace(tmpstr.begin(), tmpstr.end(), ',', ' ');
		std::istringstream(tmpstr) >>
			grpno >> imgno >> time >> tmpstr2;
		data.push_back(std::vector<int>{grpno, imgno, time,tmpstr2.compare("")==0?(int)(data.size()+1):std::stoi(tmpstr2)});
	}
	if(data[data.size() - 1][3]==data.size()){
		data[data.size() - 1][3] = 0;
	}
}

//ポトレをアニメーションさせる関数
void PotAnim(const char* path){
	
	//ポトレ管理用アドレスのポインタ
	const int *ad=*((int**)0x4b54c8);

	//ポトレ読み込み関数
	const auto load = (int (*)(const char *, int *))0x454c10;
	
	//dist:管理用アドレスから自キャラのポトレ情報までの距離
	const int dist = (int)path-(*((int*)0x4b54c8)+0x234);
	//elem:アニメーション用 今何枚目を表示するか
	int elem=0;

	//タイマー
	int timer = 0;
	
	//ポトレ読み込み関数の引数用
	int no[5]={9000,0,9000,1,-1};
	
	//sffのパス用
	std::string sffpath=path;
	
	//各画像の表示時間定義配列
	std::vector<std::vector<int>> elemdata;

	//アニメ定義を読み込む
	ReadDataFile(elemdata, (sffpath+CSVPATH).c_str());

	//読み込んだ画像のアドレス用配列
	std::vector<int> elements(elemdata.size(),0);
	
	//引数をもとにパスを変数にコピー、sffの名前を結合 sffファイルのパスが完成
	sffpath+=SFFNAME;

	

	//終わらないように
	while(1){
		timer++;
		//時間が来たら
		if(timer==elemdata[elem][2]){
			
			//コマを進める
			elem = elemdata[elem][3];
			//アドレスの配列が埋まるまで
			if(elements[elem]==0){
				no[0]=9000;
				no[1]=0;
				no[2]=elemdata[elem][0];
				no[3]=elemdata[elem][1];

				//画像を読み込んでそのアドレスを配列に
				elements[elem]=TuneForPot((*load)(sffpath.c_str(),no));
			}
			
			//大ポトレを指定のコマに設定
			*(int*)(ad+0x434/4+dist/4)=elements[elem];

			timer = 0;
		}

		//試合中になったら
		if(*(*((int **)0x4b5b4c)+0xac4/4)){
			//ポトレを元に戻して
			no[0]=9000;
			no[1]=0;
			no[2]=9000;
			no[3]=1;
			*(int*)(ad+0x434/4+dist/4)=TuneForPot((*load)(sffpath.c_str(),no));
			//スレッド終了
			break;
		}
		//スリープ処理 60回/sで実行されるように
		std::this_thread::sleep_for(std::chrono::milliseconds((int)((1.0/60)*1000)));
		
	}
}
